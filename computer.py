# computer.py is the module for executing intcode programs.
import pdb

# Define the opcodes.
OPCODE_SUM = 1
OPCODE_MULTIPLY = 2
OPCODE_INPUT = 3
OPCODE_OUTPUT = 4
OPCODE_JUMP_IF_TRUE = 5
OPCODE_JUMP_IF_FALSE = 6
OPCODE_LESS_THAN = 7
OPCODE_EQUALS = 8
OPCODE_RELBASE_OFFSET = 9
OPCODE_HALT = 99

# Define the parameter modes.
PARAM_MODE_POSITION = 0
PARAM_MODE_VALUE = 1
PARAM_MODE_RELATIVE = 2

# Different ways a program can finish its execution.
FINISH_HALT = 0
FINISH_FIRST_OUTPUT = 1
FINISH_ERROR = 10

# A class that defines a program.
class Program():
    # If I don't receive instructions, set them to an empty list.
    def __init__(self, instructions=[]):
        # Copy the instructions.
        self.instructions = copyList(instructions)
        self.length = len(self.instructions)

        # Set some default values.
        self.position = 0
        self.terminal = True
        self.inputs = []
        self.outputs = []
        self.returnOnOutput = False
        self.relativeBase = 0
    
    # The program receives a new set of instructions.
    def setInstructions(self, instructions):
        self.instructions = copyList(instructions)
        self.length = len(self.instructions)
    
    # Returns a copy of the current instructions.
    def getInstructions(self):
        return copyList(self.instructions)
    
    # Decide if you want the outputs printed to the terminal.
    def printOutputs(self, decision):
        self.terminal = decision
    
    # Reset the instruction position to the beginning.
    def resetPosition(self):
        self.position = 0
    
    # Requests that the program returns on the first output.
    def returnOnFirstOutput(self, decision):
        self.returnOnOutput = decision
    
    # Receives a list of integer inputs and stores them for later use
    # on input instructions.
    def setInputs(self, input):
        self.inputs = copyList(input)
    
    # Adds to the existing inputs.
    def appendToInputs(self, values):
        for value in values:
            self.inputs.append(value)
    
    # Returns a copy of the outputs generated by the program.
    def getOutputs(self):
        return copyList(self.outputs)
    
    def emptyOutputs(self):
        self.outputs = []
    
    # Receives a number as the address we want to write to. If there is no memory yet at
    # that address, fill the existing instructions until that address with zeros.
    def check(self, number):
        if number >= len(self.instructions):
            for i in range(number - len(self.instructions) + 1):
                self.instructions.append(0)
        
        return number
    
    # The place to store a value depends if the address is given in positional
    # or relative mode.
    def storeAt(self, address, mode, value):
        if mode == PARAM_MODE_POSITION:
            self.instructions[self.check(address)] = value
        elif mode == PARAM_MODE_RELATIVE:
            self.instructions[self.check(address + self.relativeBase)] = value
    
    # Executes the instructions of this program with the current settings.
    def execute(self):
        while self.position < self.length:

            # Parse the next opcode.
            opcode = Opcode(self.instructions[self.check(self.position)])

            # Execute the appropriate operation.
            if opcode.opcode == OPCODE_SUM:
                self.executeSum(opcode)
            elif opcode.opcode == OPCODE_MULTIPLY:
                self.executeMultiplication(opcode)
            elif opcode.opcode == OPCODE_INPUT:
                self.executeInput(opcode)
            elif opcode.opcode == OPCODE_OUTPUT:
                self.executeOutput(opcode)
                if self.returnOnOutput:
                    return FINISH_FIRST_OUTPUT
            elif opcode.opcode == OPCODE_JUMP_IF_TRUE:
                self.executeJumpIfTrue(opcode)
            elif opcode.opcode == OPCODE_JUMP_IF_FALSE:
                self.executeJumpIfFalse(opcode)
            elif opcode.opcode == OPCODE_LESS_THAN:
                self.executeLessThan(opcode)
            elif opcode.opcode == OPCODE_EQUALS:
                self.executeEquals(opcode)
            elif opcode.opcode == OPCODE_RELBASE_OFFSET:
                self.executeRelativeBaseOffset(opcode)
            elif opcode.opcode == OPCODE_HALT:
                return FINISH_HALT
            else:
                print('ERROR: opcode {} not recognised by the computer'.format(self.instructions[self.position]))
                return FINISH_ERROR
    
        return FINISH_ERROR
    
    # Execute the sum operation.
    def executeSum(self, opcode):
        # Parse the parameters to know the values.
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 2, self.relativeBase, self)

        # Store the result at the appropriate address.
        mode = opcode.modes[2] if len(opcode.modes) >= 3 else PARAM_MODE_POSITION
        self.storeAt(self.instructions[self.check(self.position + 3)], mode, values[0] + values[1])
        #self.instructions[self.check(self.instructions[self.check(self.position + 3)])] = values[0] + values[1]

        # Update the position of the next instruction.
        self.position += 4
    
    def executeMultiplication(self, opcode):
        # Parse the parameters to know the values.
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 2, self.relativeBase, self)

        # Store the result at the appropriate address.
        mode = opcode.modes[2] if len(opcode.modes) >= 3 else PARAM_MODE_POSITION
        self.storeAt(self.instructions[self.check(self.position + 3)], mode, values[0] * values[1])
        #self.instructions[self.check(self.instructions[self.check(self.position + 3)])] = values[0] * values[1]

        # Jump four positions.
        self.position += 4

    def executeInput(self, opcode):
        # Decide if the input was given, else ask for it from the command line.
        if self.inputs != None and len(self.inputs) >= 1:
            number = self.inputs[0]
            del self.inputs[0]
        else:
            number = input('Input: ')

        # Store it at the selected position.
        mode = opcode.modes[0] if len(opcode.modes) >= 1 else PARAM_MODE_POSITION
        self.storeAt(self.instructions[self.check(self.position + 1)], mode, int(number))
        #self.instructions[self.check(self.instructions[self.check(values[0])])] = int(number)

        # Update position.
        self.position += 2
    
    def executeOutput(self, opcode):
        # Find the value to output.
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 1, self.relativeBase, self)

        # Store the value in the output list.
        self.outputs.append(values[0])

        # Print to the terminal if requested.
        if self.terminal:
            print('Output: {}'.format(values[0]))

        # Update the position.
        self.position += 2

    def executeJumpIfTrue(self, opcode):
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 2, self.relativeBase, self)

        self.position = values[1] if values[0] != 0 else self.position + 3
    
    def executeJumpIfFalse(self, opcode):
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 2, self.relativeBase, self)

        self.position = values[1] if values[0] == 0 else self.position + 3
    
    def executeLessThan(self, opcode):
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 2, self.relativeBase, self)

        # Store a 1 if less than, else store a 0.
        mode = opcode.modes[2] if len(opcode.modes) >= 3 else PARAM_MODE_POSITION
        self.storeAt(self.instructions[self.check(self.position + 3)], mode, 1 if values[0] < values[1] else 0)
        #self.instructions[self.check(self.instructions[self.check(self.position + 3)])] = 1 if values[0] < values[1] else 0

        self.position += 4
    
    def executeEquals(self, opcode):
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 2, self.relativeBase, self)

        # Store a 1 if equals, else store a 0.
        mode = opcode.modes[2] if len(opcode.modes) >= 3 else PARAM_MODE_POSITION
        self.storeAt(self.instructions[self.check(self.position + 3)], mode, 1 if values[0] == values[1] else 0)
        #self.instructions[self.check(self.instructions[self.check(self.position + 3)])] = 1 if values[0] == values[1] else 0

        self.position += 4
    
    def executeRelativeBaseOffset(self, opcode):
        values = parseParameters(self.instructions, self.position + 1, opcode.modes, 1, self.relativeBase, self)

        # Adjust the relative base by the value of the only parameter.
        self.relativeBase += values[0]

        # Jump two positions.
        self.position += 2

# Stores information about an opcode.
class Opcode():
    def __init__(self, opcode):
        # Get the opcode itself.
        self.opcode = opcode % 100

        # Get the parameters modes.
        self.modes = []
        value = int(opcode / 100)
        while value >= 1:
            self.modes.append(value % 10)
            value = int(value / 10)

# Creates a copy of the list provided as a parameter.
def copyList(givenList):
    result = []
    for element in givenList:
        result.append(element)
    
    return result

# Receives a filename and returns a program with the instructions set to the
# values inside the file.
def readProgramFromFile(filename):
    return Program(readInstructionsFromFile(filename))

# Reads instructions from a file and returns them.
def readInstructionsFromFile(filename):
    with open(filename, 'r') as inputFile:
        instructions = [int(element) for element in inputFile.read().rstrip('\n').replace(' ', '').split(',')]
    
    return instructions

def copyProgram(initialProgram):
    return Program(initialProgram.instructions)    

# Receives a starting position and a set of instructions, and returns the values for the parameters.
# If in positional mode, it accessess the address, else it returns the value itself.
def parseParameters(instructions, position, modes, totalParameters, relativeBase, program):
    values = []
    for i in range(totalParameters):
        if i < len(modes):
            # This parameter has a mode associated with it.
            if modes[i] == PARAM_MODE_POSITION:
                value = instructions[program.check(instructions[program.check(position + i)])]
            elif modes[i] == PARAM_MODE_VALUE:
                value = instructions[position + i]
            elif modes[i] == PARAM_MODE_RELATIVE:
                value = instructions[program.check(instructions[program.check(position + i)]  + relativeBase)]
        else:
            # No mode has been supplied, the default is position mode.
            value = instructions[program.check(instructions[program.check(position + i)])]
        values.append(value)

    return values

